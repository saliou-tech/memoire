\section{cryptosystéme simplement homomorphe de RSA }
L'algorithme RSA conçu par Rivest, Shamir et Adleman en 1978 est largement utilisé aujourd'hui pour transmettre en toute sécurité de petites clés secrètes entre les deux parties, qui peuvent ensuite être utilisées pour communiquer en toute sécurité  avec des messages beaucoup  plus importants grâce à des systèmes de chiffrement à clé privée efficaces.(chiffrement hybride)\\
Nous allons explorer les propriétés homomorphes que le RSA possède, même s'il n'a pas été spécifiquement conçu dans ce but. Tout d'abord, nous définissons formellement le RSA ci-dessous :\\
\begin{algorithm}[H]
$
\Procedure{GEN}{$(1^{\lambda}) }
  \State On Choisit 2 nombres premiers  aléatoires p, q, et on  calcule N = pq
  \State On calcule $\phi{(N)}$=$(p-1)(q-1)$
  \State On choisit e >1 tel que pgcd(\phi{(N)}$ ,e)=1   et on calcule  d= e^{-1}mod \ \phi{(N)}$
 \State \textbf{return} $(N,e,d)$
\EndProcedure

\Procedure{ENC}{$(m,N,e)$}
 \State \textbf{return} $c= m^{e}mod \ d$
\EndProcedure

\Procedure{DEC}{$(c,N,d)$}
 \State \textbf{return} $m= c^{d}mod \ N$
\EndProcedure



 \caption{Algorithme de RSA \cite{1}}
\end{algorithm}
\\
Nous pouvons facilement voir que les schémas de chiffrement  et de déchiffrement de  RSA sont corrects puisque on a :
\begin{align*}
  DEC{_(}{_N,}{_d}{_)}(ENC{_(}{_N,}{_e}{_)})(m)&=  DEC{_(}{_N,}{_d}{_)}(m^{e} mod \ N)\\
                                               &=m^{de} mod \ N \\
                                               &=m \ mod \ N
\end{align}
De plus, notez que l'algorithhme  RSA prend pour acquis que nous pouvons générer des nombres premiers de $\lambda$-bit  pour tout $\lambda$ $\in$ $ \mathbf{Z}^{+}$ . Ce n'est certainement pas une hypothèse triviale, mais de nombreux schémas simples qui génèrent des nombres de $\lambda$-bit aléatoires et utilisent des tests de primalité comme le test de Miller-Rabin fonctionnent bien en pratique \cite{1}. Une discussion plus approfondie des méthodes permettant de générer des nombres premiers  de  $\lambda$-bit dépasse le cadre de ce mémoire , nous supposerons donc que nous pouvons générer efficacement de tels nombres premiers.
\\
Dans ce qui , nous montrerons que RSA est un schéma de chiffrement homomorphe valide qui supporte la multiplication
modulo N.
\subsubsection{Proposition1}
 RSA  est un schema  de chiffrement valide et partiellement homomorphe. En particulier, la multiplication des messages chiffrés modulo N correspond à la multiplication des messages clairs modulo N.
 \subsubsection{Démonstration}
 Soit $ENC{_(}{_N,}{_e}{_)}$ l'algorithme de chiffrement et $m{_1}$ et $m{_2}$ $\in$ $ \mathbf{Z}_{N}$  deux messages,alors on a
\begin{align*}
  ENC{_(}{_N,}{_e}{_)}(m{_1})ENC{_(}{_N,}{_e}{_)}(m{_2})&=m{_1}^e.m{_2}^e mod \ N \\
                                                        &=(m{_1}m{_2})^e mod \ N \\
                                                        &=ENC{_(}{_N,}{_e}{_)}(m{_1}m{_2})
\end{align*}
Ainsi, on peut voir que multiplier les chifrés modulo N correspond à multiplier les messages en clair modulo N.\\
Malheureusement, même si nous prenons l'hypothèse RSA comme acquise, il existe un certain nombre d'attaques sur le RSA  qui le rendent peu sûr \cite{1}. En fait, comme le RSA est déterministe, il ne peut pas être CPA-sùr. Cependant, nous pouvons au moins voir que l'idée d'un chiffrement homomorphe est réalisable car RSA est capable d'obtenir l'homomorphisme sans que ce soit son objectif.
\section{Cryptosystème de Paillier}
Dans cette section, nous explorons un schéma de chiffrement homomorphe additif proposé par Paillier en 1999 \cite{11}.Ce schéma utilise le problème de la classe de résidu composite, qui est étroitement lié au système RSA.Bien qu'il ne soit pas totalement homomorphe, le schéma de chiffrement de Paillier est utilisé dans de nombreuses  applications de machine learning  que nous explorons dans ce mémoire. Une caractéristique intéressante du cryptosystème de Paillier est qu'il est homomorphe sur un grand nombre de messages , c'est-à-dire sur $\mathbb{Z}_\mathbb{N}$. Un exemple courant de cas d'utilisation du cryptosystème de Paillier
est le calcul du nombre de votes chiffrés, puisque les sommes résultantes peuvent atteindre des totaux élevés \cite{1}.Depuis sa création, le cryptosystème de Paillier a également subi des améliorations pour le rendre plus efficace .Nous décrivons l'algorithme ci-dessous (Algorithme 2), nous illustrons la réduction à RSA et nous donnons une
preuve de sécurité, en suivant les exposés de \cite{11}, \cite{1}. En particulier, nous présentons de nombreux détails de \cite{11} mais pour la clarté de la présentation, nous utilisons la notation et la terminologie de \cite{1}.
\subsection{Le système de chiffrement }
Pour le cryptosystème de Paillier, l'espace de message M = $\mathbb{Z}_{N}$ ,l'espace de clés $\mathcal{K}$= $\mathcal{K}${_p_k}$ $ $\times$ $\mathcal{K}${_s_k}$ où $\mathcal{K}${_p_k}$=$\mathbb{Z}_{N}$ et l' espace des  chiffrés $\mathcal{C}$=$\mathbb{Z}_{N^2}$
\begin{algorithm}[H]
  \Procedure{GEN}{$(1^\lambda)$}
  \State On Choisit 2 nombres premiers aléatoires p, q, de $\lambda$-bit
  \State On calcule N=pq et $\phi{(N)}$=$(p-1)(q-1)$

   \State \textbf{return} (N,$\phi{(N)} $)
  \EndProcedure
\Procedure{ENC}{$(m,N)$}
  \State r $\leftarrow $  $\mathbb{Z}_{N^*}$
  \State $c=(1+N)^m.r^n(mod \ N^2)$
 \State \textbf{return} $c$
\EndProcedure

\Procedure{DEC}{$(c,N,\phi{(N)})$}
\State Calculer  $ \widetilde{c} = c^{\phi{(N)}} mod \ N^2 $
\State Calculer $\widetilde{m}=\frac{\widetilde{c}-1}{N}$
\State Calculer $m=\widetilde{m}.\phi{(N^-1) mod \ N^2$
 \State \textbf{return} $m$
\EndProcedure


 \caption{Algorithme de Paillier \cite{1} ,\cite{11}}
\end{algorithm}
Pour démontrer l'exactitude du cryptosystème de Paillier, nous examinons l'espace du texte chiffré : le groupe$\mathbb{Z^*}_{N^2}$ sous multiplication modulo $N^2$ et introduisons la notion de  $N^{ieme}$ résidus, qui sont importants pour le cryptosystème de Paillier.
\subsubsection{}
Un entier z $\in$ $\mathbb{Z^*}_{N^2}$  est  un $N^{ieme}$ résidus modulo $N^2$ ,s'il existe y $\in$ $\mathbb{Z^*}_{N^2}$ tel que
\begin{equation}
  z &\equiv y^N \mod N^2 \\

\end{equation}
Pour revenir à la démonstration de  l'exactitude du cryptosytéme, nous devons prouver que le schéma de chiffrement  est univoque et que le système de déchiffrement est correct. La première est importante car si deux plaintexts sont mis en correspondance avec le même ciphertext, alors l'algorithme de déchiffrement ne pourra pas déchiffrer correctement. Donc, fixons un $N^{ieme}$ résidu g $\in$ $\mathbb{Z^*}_{N^2}$ et Notons  $\epsilon_{g}$  la fonction
\begin{align}
  \epsilon_{g}:\mathbb{Z}_{N} \times \mathbb{Z^*}_{N} \longrightarrow  \mathbb{Z^*}_{N^2}\\
               (x,y) \longrightarrow  g^x.y^N (mod \ N^2)
\end{align}
\subsubsection{lemme 1}
Si l'ordre de g $\in$ $ \mathbb{Z^*}_{N^2}$ est un miltiple non nul de N ,alors $\epsilon_{g}$ est bijective
\subsubsection{preuve}
Nous allons d'abord montrer que  $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ et $ \mathbb{Z^*}_{N^2}$ ont le meme nombre d'élements,
 $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ a N $\phi{(N)}$élements avec $\phi{}$la fonction d'Euler .\\
 Soit $N=\prod_{i}p{_i}^{e{_i}}$ la décomposition en produit de facteur premier de N.notez que
 \begin{align*}
   \phi{(N)}&=\prod_{i}\phi{(p{_i}^{e{_i}})}
                ( \phi{}  est multiplicative)
           \\  &=\prod_{i}p{_i}^{e{_i}-1}(p{_i}-1)
 \end{align*}
Ainsi on a,
\begin{align*}
  \phi{(N^2)}&=\prod_{i}\phi{(p{_i}^{2e{_i}})}\\
             &=\prod_{i}p{_i}^{2e{_i}-1}(p{_i}-1)\\
             &=(\prod_{i}p{_i}^{e{_i}})(\prod_{i}p{_i}^{e{_i}-1}(p{_i}-1))\\
             &=N\phi{(N)}
\end{align*}
Ainsi  $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ et $ \mathbb{Z^*}_{N^2}$ ont le meme nombre d'élements,il suffit alors de montrer que $\epsilon_{g}$ est injective.\\\
Supposons que $g^{x{_1}}.y_{1}^{N}=g^{x{_2}}.y_{2}^{N} (\ mod \ N^2) \implies g^{x{_2}-x{_1}}(\frac{y_{2}}{y_{1}})^N &\equiv 1 \mod N^2 $. soit $\lambda$ le plus grand entier pour lequel il existe un élément de $ \mathbb{Z^*}_{N^2}$ d'ordre $\lambda$N.Ainsi $ (\frac{y_{2}}{y_{1}})^{\lambda N} &\equiv 1 \mod N^2 \implies g^{\lambda(x{_2}-x{_1})} &\equiv 1 \mod N^2  $.
Ceci implique que $\lambda(x{_2}-x{_1}) $ est un multiple de l'ordre de g et donc un multiple de N.Ainsi $Pgcd(\lambda ,N)=1 \implies  x{_2}-x{_1} &\equiv 0 \mod N$ donc $(\frac{y_{2}}{y_{1}})^N &\equiv 1 \mod N^2 $ qui admet une solution unique $\frac{y_{2}}{y_{1}}=1 $ sur $ \mathbb{Z^*}_{N^2}$.d'où x{_1}$- x{_2}$=0 et y{_1}$- y{_2}$=0 et $\epsilon_{g}$ est bijective\\
\\
Il découle alors de la bijectivité que l'algorithme de chiffrement ne fait pas correspondre deux messages distincts sur le même texte chiffré. Quant à l'exactitude de l'algorithme de déchiffrement du cryptosystème de Paillier, nous avons la proposition suivante
\subsubsection{Proposition2}
L'algorithme de déchiffrement du cryptosystème Paillier est correct. Plus précisément, pour un certain m $\in$ \mathbb{Z}_{N}  , alors$DEC_{\phi{(N)}}(ENC_{N}(m))=m$
\subsubsection{démonstration}
Observons que
\begin{align*}
   \widetilde{c}&=c^{\phi{(N)}} mod \ N^2 \\
                &=(1+N)^{m\phi{(N)}}r^{n\phi{(N)}} mod \ N^2\\
                &\leftrightarrows (m\phi{(N)mod \ N},r^{\phi{(N)}}mod \ N)            \ (bijection)\\
                &=(m\phi{(N)mod \ N},1)                \  \ (r^{\phi{(N)}}=1 mod N ,si r et N sont premiers entre eux)\\
                &\leftrightarrows (1+N)^{m\phi{(N)}} mod \ N^2   \ (bijection)\\
                &=1+ m\phi{(N)}N \ mod \ N^2
\end{align*}
Ainsi , on obtient
\begin{align*}
  (\frac{\widetilde{c}-1}{N}).\phi{(N)}^{-1}=m
\end{align*}
Ainsi le schéma de déchiffrement est donc correcte\\
Maintenant que nous avons vérifié l'exactitude des algorithmes de chiffrement et de déchiffrement, nous pouvons passer à l'examen de la sécurité du cryptosytéme de Paillier. Le problème difficile sur lequel le cryptosystème de Paillier est basé est le problème de résidu composite décisionnel, qui consiste à distinguer
entre les éléments uniformes de $ \mathbb{Z^*}_{N^2}$ et les $ n^{ieme}$  residus de $ \mathbb{Z^*}_{N^2}$.Plus formellement, nous définissons ce que signifie le fait que le problème de résidu composite décisionnel soit difficile, en utilisant la définition de \cite{1}.
\subsubsection{Définition 1}
Le problème de la résiduosité composite décisionnelle est difficile si, pour tous les algorithmes probabilistes en temps polynomial D, il existe une fonction négligeable negl telle que pour r choisi aléatoirement parmi $ \mathbb{Z^*}_{N^2}$
\begin{align*}
  |Pr[ D(N,r^{N} mod \ N^2)=1]-Pr[D(N,r)=1]| \leq negl(n)
\end{align*}
Dans la présentation originale de ce schéma par Paillier, il explore le problème de la $n^{ieme}$  classe de résidu et démontre que sa résolution nous donne un distinguateur pour le problème de résidu composite décisionnel ci-dessus. La  $n^{ieme}$  classe de résidu est définie comme suit :
\subsubsection{Définition 2}
Soit g $\in$ $ \mathbb{Z^*}_{N^2}$ ayant un ordre non nul multiple  de N. Nous appelons la $N^{ieme}$ classe de résidu de w par rapport à g, l'unique entier $ [[w]]_{g}$ $\in$ $Z_{n}$ pour lequel il existe y tel que
\begin{align*}
  \epsilon_{g}([[w]]_{g},y) &=  ([[w]]_{g})^{g}.y^N =w
\end{align*}
Notez que ce problème est bien défini car $[[w]]_{g}$ est unique, ce qui vient du fait que $\epsilon_{g}$ est bijective (par le Lemme).
\subsection{Réduction en RSA}
\subsubsection{Définition 3}
Le $N^{ieme}$ problème de classe de résidu de la base g, Classe[N, g] est le problème suivant. Étant donné
w $\in$ $ \mathbb{Z^*}_{N^2}$ et une base g, calculer  $[[w]]_{g}$ .\\

Le résultat suivant nous montre  comment le problème de la $N^{ieme}$ Classe de Résiduosité nous donne un distinguateur D pour le problème de la résiduosité composite décisionnelle.
\subsubsection{lemme 2}
$[[w]]_{g}$ = 0 si et seulement si w est un Nième résidu modulo $N^2$ \\
\subsubsection{Démonstration}
Voir \cite{11} pour la démonstration.
\\
\\
Ainsi, si nous pouvions résoudre le probléme de la $N^{ieme}$ classe de résidu, un simple distinguateur D pourrait prendre r et calculer $[[r]]_{g}$ pour un certain g approprié. Si le résultat est 0 , alors il sort 1 (en devinant que c'est un $N^{ieme}$ résidu).Sinon, il produit 0.Il est facile de voir que cela présente un avantage non négligeable.En effet, par le lemme 1 et le lemme précédent, une proportion non triviale d'éléments de $ \mathbb{Z^*}_{N^2}$ ne sont pas des $N^{ieme}$ résidus, c'est-à-dire exactement une proportion $\frac{N-1}{N}$ d'entre eux.
\\
Jusque ici , une instanciation particulière du problème de la $N^{ieme}$ classe de résidu dépend de plusieurs paramètres, à savoir N, g et w. D'après les deux lemmes suivants, il s'avère que tous ces paramètres n'influencent pas la difficulté du problème. Tout d'abord, notons que dans la construction de ce distinguateur, nous n'avons pas précisé quelle valeur de g choisir. Le lemme suivant nous montre que cela n'a pas d'importance.
\subsubsection{lemme 3}
La classe [N, g] est aléatoirement auto-réductible sur tous les g' dont l'ordre est un multiple non nul de N.
\subsubsection{démonstration}
Voir \cite{11} pour la démonstration
\\
\\
Une autre propriété intéressante de la classe [N, g] est le fait qu'elle est aléatoirement auto-réductible. Plus précisément, nous pouvons réduire une instance du problème pour une valeur w $\in$ $ \mathbb{Z^*}_{N^2}$ en une instance aléatoire w' $\in $ $ \mathbb{Z^*}_{N^2}$    tiré d'une distribution uniforme.
\subsubsection{lemme 4}
La classe [N, g] est aléatoirement auto-réductible sur w $\in$ $ \mathbb{Z^*}_{N^2}$
\subsubsection{démonstration}
En effet, on peut facilement transformer tout w $\in$ $\mathbb{Z^*}_{N^2}$ en une instance aléatoire w' $\in$
$\mathbb{Z^*}_{N^2}$ avec une distribution uniforme, en posant  $w' = w g^{a}b^n mod N^2$ où a et b sont pris uniformément au hasard sur $ \mathbb{Z}_{N}$  (l'événement b $\notin$ $ \mathbb{Z}_{N}$ se produit avec une probabilité négligeable). Après avoir calculé $[[w']]_{g}$ , il suffit de retourner $[[w]]_{g} = [[w']]{_g} - a mod N$.
\\
Ainsi, nous voyons que nos choix de w $\in$ $\mathbb{Z^*}_{N^2}$ et g un $N^{ieme}$ résidu modulo N n'affectent pas la difficulté du problème de la  $N^{ieme}$ classe de résidu. Par conséquent, il nous suffit de choisir le paramètre N, et nous pouvons donc désigner une instanciation de ce problème par Classe[N].

\subsubsection{Théoréme (Réduction en RSA)}
La classe [N] est réductible en RSA
\subsubsection{Démonstration}
Nous savons que les élements de la classe [N, g] avec un ordre non nul multiple de N sont équivalentes  à g .En utilisant g = 1 + N, nous avons seulement besoin de montrer que
\begin{align*}
  RSA \rightrightarrows Class[N, 1 + N]
\end{align*}
Supposons maintenant que nous ayons un oracle S pour RSA .
\\
On a  $c=(1+N)^{m}y^{N} mod \ N^2$ avec m  $\in$  $ \mathbb{Z}_{N}$  et y $\in$  $ \mathbb{Z^*}_{N}$ .En developpant  $(1+N)^m$ (avec la loi de binome) et en appliquant la reduction modulo N on obtient $c=y^N mod \ N$ et on peut calculer y en utilisant l'oracle  S .On a alors $y=S(c mod \ N)$ ainsi nous avons
\begin{align*}
              c&=(1+N)^my^N mod \ N^2\\
 \frac{c}{y^N}&=(1+N)^m mod \ N^2\\
              &=1+mN \ mod \ N^2
\end{align*}
Ainsi on pourra  calculer  $m = [[c]]_{1+N}$  , comme souhaité, ce qui résout la classe [N]
\\
Ainsi, nous avons montré que le problème décisionnel du  cryptosystème de Paillier et RSA sont des schémas de chiffremente étroitement liés en ce sens et  que le premier est au plus aussi difficile que la factorisation du RSA. Cependant, cela ne le rend pas automatiquement sûr. Ci-dessous, nous montrons que le cryptosystème de Paillier est CPA-sécurisé en supposant que le problème de résidu composite décisionnel est difficile, en utilisant une preuve  de \cite{1}.
\subsection{Preuve de sécurité}
Avant de présenter la preuve de la sécurité, nous montrons un résultat standard de la théorie des groupes.
\subsubsection{proposition 3}
Si G est un groupe fini et que g $\in$ G soit choisi arbitrairement. Alors, si on choisit une distribution uniforme
k $\in$ G, alors la distribution de $ g \circ k$ ∈ G est également uniforme.
\subsubsection{Démonstration}
On a   pour tout g' $\in$ G ,il existe un k $\in$ G (c-à-d $k=g^{-1}\circ g'$) tel que \\
$g \circ k=g\circ g^{-1} \circ g' =g'$
\\
Maintenant, nous pouvons prouver la sécurité CPA conditionnelle du cryptosystème de Paillier.
\subsubsection{Théorème}
Si le problème de résidu composite décisionnel est difficile, alors le cryptosystème de Paillier
est CPA-sécurisé.
\subsubsection{démonstration}
Soit $ \epsilon = (GEN, ENC, DEC) $ le cryptosystème de Paillier. Comme le système de Paillier est un schéma de chiffrement à clé publique, il suffit de montrer que E est sécurisé par EAV. Alors, par la proposition 2 du chapitre 1 , cela implique qu'il est sécurisé par CPA.
Nous allons construire  une réduction du problème de résidu composite décisionnel pour casser la sécurité EAV pour le cryptosystème de Paillier. Ensuite, comme nous supposons que le problème de résidu composite décisionnel est difficile, nous ne devons pas être en mesure de casser la sécurité EAV pour le cryptosystème de Paillier.
Soit $\mathbb{A }$ un adversaire probabiliste en temps polynomial. Considérons l'algorithme D suivant qui tente de résoudre le problème de résidu composite décisionnel en se déroulant  comme suit et prenant en  entrée N, et y\\
1.) Définir $ pk = N$ et exécuter $ \mathbb{A}(pk)$ pour obtenir deux messages $m_{0}$, $m_{1}$ $\in$ M\\
\\
2.)Choisir un bit uniforme b $\in$  $\{ 0,1 \}$   et calculer le  chiffré $c=(1 +N)^{m_{b}}.y mod \ N^2$\\
3.)On donne le chiffré c à $\mathbb{A}$ comme challenge et $\mathbb{A}$  produit un bit b' .Si b=b'  on sort 1 sinon 0\\
Premièrement, si l'entrée de D avait un y qui a été tiré de en prenant un aléa  r $\in$ $\mathbb{Z^*}_{N^2}$ et en l'élevant à la puissance N, on aura alors $c=(1 +N)^{m_{b}}.r^N mod \ N^2$ .Dans ce cas, nous notons que si  $\mathbb{A}$  a été capable de distinguer correctement les chifrés de $m_{0}$ et $m_{1}$ (c'est-à-dire si b = b'), cela est équivalent à ce que D réussisse à déterminer si y a été tiré uniformément de $\mathbb{Z^*}_{N^2}$ ou de $ Res(N^2)$ . Par conséquent, nous avons que.
\begin{align*}
Pr[ D(N,r^{N} mod \ N^2)=1]=Pr[PubK^{eav}{_A,_{\epsilon}}(n) =1]
\end{align*}
Maintenant, on observe que si notre entrée à D avait un y qui était tiré au hasard de $\mathbb{Z^*}_{N^2}$ , alors par la Proposition 3 précédent, le texte chiffré c est distribué uniformément dans $\mathbb{Z^*}_{N^2}$  ,indépendamment de m. Ainsi, la probabilité que $ b'= b$ est exactement $\frac{1}{2}$ et en particulier
\begin{align*}
  Pr[ D(N,r)=1]&=\frac{1}{2}
\end{align*}
Maintenant, en utilisant l'hypothèse que le problème de résidu composite décisionnel est dur, nous savons  alors  qu'il  existe une fonction négligeable negl telle que
\begin{align*}
  |Pr[D(N,r^{N} mod \ N^2)=1]- Pr[ D(N,r)=1]|\leq negl(n)
\end{align*}
en remplaçant on a
\begin{align*}
   |Pr[PubK^{eav}{_A,_{\epsilon}}(n) =1]-\frac{1}{2}|\leq negl(n)
\end{align*}
et donc
\begin{align*}
   |Pr[PubK^{eav}{_A,_{\epsilon}}(n) =1]|\leq  \frac{1}{2} + negl(n)
\end{align*}
Cela montre donc que le cryptosytéme de Paillier est sécurisé par EAV, et donc sécurisé par CPA.
\section{Chiffrement entièrement homomorphe à partir de l'apprentissage avec erreurs (LWE)}
Jusqu'à présent, les systèmes que nous avons examinés (c'est-à-dire RSA et le cryptosystème Paillier) étaient partiellement homomorphes. Les cryptosytémes partiellement homomorphes sont limités dans la mesure où ils ne supportent pas l'évaluation de toutes les fonctions f possibles sur les textes chiffrés.  Cette restriction limite la mesure dans laquelle ils peuvent être utilisés, comme dans les cas où nous ne savons pas quelles opérations spécifiques seront nécessaires. En effet, nous aimerions pouvoir exécuter des algorithmes de machine learning  de pointe sur  des  données chiffrées sans avoir à modifier le schéma de chiffrement chaque fois que nous devons prendre en charge une nouvelle opération, ou restreindre nos algorithmes à un certain ensemble d'opérations. \\
D'autre part, un schéma de chiffrement totalement homomorphe nous permettrait d'évaluer des fonctions arbitraires sur les données. Le premier schéma de chiffrement totalement homomorphe a été proposé par Gentry \cite{3}, en utilisant une variante plus forte de l'hypothèse d'apprentissage avec erreurs pour les treillis idéaux et une hypothèse supplémentaire sur les sommes de sous-ensembles épars. Nous ne couvrons pas la construction de Gentry dans ce mémoire, mais notons qu'elle a servi de base à de nombreux schémas de chiffrement totalement homomorphes construits par la suite.\\

Bien que le fait que nous puissions construire des schémas de chiffrement totalement homomorphes soit un énorme succès, cette flexibilité n'est pas sans inconvénients. En effet, comme indiqué dans \cite{12}, même si des solutions pour le chiffrement totalement homomorphe ont été constamment proposées et améliorées, les schémas de chiffrement totalement homomorphes semblent être loin d'être suffisamment efficaces pour être utilisés dans la pratique. Cependant, les schémas de chiffrement partiellement homomorphes ont tendance à être beaucoup plus rapides,  ce qui justifie leur utilisation dans de nombreuses applications de machine learning. Quoi qu'il en soit, nous poursuivons   dans ce qui suit une exploration du schéma de chiffrement totalement homomorphe de \cite{10}, basé sur les hypothèses LWE(learning with error).
\subsection{Le problem LWE (learning with error )}
 LWE est le  problème difficile  sur lequel repose le schéma de chiffrement entièrement homomorphe de \cite{10}. De manière informelle, cette hypothèse stipule que, étant donné $\mathbf{u}$ et$\langle \mathbf{u} , \mathbf{v} \rangle $ il est difficile de résoudre v si un petit terme de bruit est ajouté à $\langle \mathbf{u} , \mathbf{v} \rangle $. Nous donnons une définition formelle ci-dessous.
 \subsubsection{Définition 1}
 Étant donné un paramètre de sécurité $\lambda$, soit $ n = n(\lambda)$  une dimension entiére, $ q = q(\lambda) \geq 2$ un entier et $ \chi = \chi(\lambda)$  une distribution sur \mathbb{Z}. Le problème de l'apprentissage avec erreurs (LWE) est de distinguer les deux distributions suivantes :\\

 1)Dans la première distribution, on échantillonne $ (\mathbf{a_{i}}, b_{i})$  uniformément de $\mathbf{Z^{n+1}}_{q}$\\
 2)Dans la deuxième distribution, on tire d'abord $ s \leftarrow $   $\mathbf{Z^n}_{q}$ uniformément, puis on échantillonne $(\mathbf{a_{i}}, b_{i})$  $\in $ $\mathbf{Z^{n+1}}_{q}$ en échantillonnant $ \mathbf{a_{i}} \leftarrow \mathbf{Z^n}_{q}$ uniformément, $ e_{i} \leftarrow \chi$ , et en fixant $ b_{i}= \langle \mathbf{a_{i}} , s \rangle  + e_{i}$.\\
 L'hypothèse d'apprentissage avec des erreurs (LWE ) est alors que le problème ci-dessus est irréalisable.
\subsection{Généralités  sur le schéma :La méthode des vecteurs propres approximatifs}
L'idée générale de ce schéma de chiffrement est de réaliser un chiffrement homomorphique basé sur LWE où les opérations d'addition et de multiplication correspondent directement à l'addition et à la multiplication de matrices. L'idée générale est qu'étant donné un message m et une clé secrète v avec au moins un  coefficient $v_{i}$ grand , le texte chiffré est alors  une matrice C telle que
\begin{align*}
  C.v = m.v + e
\end{align*}
avec e un vecteur d'erreur faible\\
Par conséquent, la clé secrète v est un vecteur propre approximatif du texte chiffré C avec une valeur propre égale au message m. Pour déchiffrer, nous allons extraire la ième ligne de C (correspondant à la plus  grande entrée dans v, vi), et calculons
\begin{align*}
  x = \langle C_{i} , v_{i} \rangle =  m.v_{i} + e_{i} \implies m=   \floor*{\frac{x}{v_{i}}}
\end{align*}
Comme l'erreur $e_{i}$ est faible par rapport au coefficient $v{i}$, elle n'affectera pas l'arrondi de $\frac{x}{v_{i}}$ et ne faussera pas le dechiffrement de m. Par conséquent, le schéma de chiffrement sera correct.
\subsection{Outils pour le chiffrement homomorphe}
D'après la Généralité précédente, nous pouvons voir qu'il est important de garder le terme d'erreur borné. Par conséquent, nous définissons ce que signifie garder un texte chiffré fortement limité et nous introduisons certaines méthodes dans l'algorithme 3 qui nous permettront de maintenir cette propriété. Pour la notation, supposons que nous ayons un vecteur $\mathbf{a}$, alors soit  $ a_{i,j} $ le jème bit (où j = 0 est le bit le moins significatif) de l'élément i du vecteur.
\subsubsection{Définition 2}
Un texte chiffré C est B-fortement-limité si son message associé m, et les coefficients de C ont une norme d'au plus 1, tandis que les coefficients de son terme d'erreur e ont une norme  d'au plus B\\
Les méthodes ci-dessous seront utilisées dans les algorithmes de chiffrement, de déchiffrement et d'évaluation homomorphes pour garder nos chifrés fortement limités. BitDecomp renvoie simplement les coefficients binaires pour chaque entrée d'un vecteur a. $ BitDecomp^{-1}$  ramène ces coefficients au vecteur a, mais notez que les entrées de  BitDecomp-1 ne doivent pas nécessairement être dans $ \{0, 1\}$ . Flatten utilise ces deux opérations pour accepter des coefficients binaires mal formés (c'est-à-dire qui ne sont pas dans $ \{0, 1\}$) et les représenter avec des coefficients binaires valides sans changer les entrées du vecteur sous-jacent. Enfin, PowersOf2 crée simplement des copies de chaque entrée multipliée par des puissances de 2$

\begin{algorithm}[H]
  \Procedure{BITDECOMP}{$(a)$}
   \State \textbf{return} $(a_{1,0}, ..., a_{1,l-1}, ..., a_{k,0}, a_{k,l-1})$
  \EndProcedure
\Procedure{BITDECOMP^{-1}}{$(a_{1,0}, ..., a_{1,l-1}, ..., a_{k,0}, a_{k,l-1})$}

 \State \textbf{return} $(\sum_{j}a_{1,j}, ...,\sum_{j}a_{k,j})$
\EndProcedure

\Procedure{FLATTEN}{$(a_{1,0}, ..., a_{1,l-1}, ..., a_{k,0}, a_{k,l-1})$}

 \State \textbf{return} $BITDECOMP(BITDECOMP^{-1}(a_{1,0}, ..., a_{1,l-1}, ..., a_{k,0}, a_{k,l-1}))$
\EndProcedure
\Procedure{POWERSOF2}{$(2)$}

 \State \textbf{return} $(b_{1},2b_{1}....,2^{l-1}b_{1},..........,b_{k},2b_{k}....,2^{l-1}b_{k})$
\EndProcedure


 \caption{Algorithme de BitDecomp, Flatten, Powersof2 }
\end{algorithm}
Quelques propriétés simples à noter à propos de ces méthodes\\
1) $\langle BitDecomp(\mathbf{a}) , Powersof2(\mathbf{b}) \rangle  = \langle \mathbf{a} , \mathbf{b} \rangle  $\\
2)Pour  a de dimension N ,Si $ a'=BitDecomp(a)$ ,$\langle \mathbf{a'} , Powersof2(\mathbf{b}) \rangle  = \langle BitDecomp^{-1}(\mathbf{a'}) , \mathbf{b} \rangle = \langle Flatten(\mathbf{a'}) , Powersof2(\mathbf{b}) \rangle  $ \\
Comme  Flatten convertit les décompositions de bits en représentations binaires valides, c'est-à-dire avec des chiffres dans $\{0, 1\}$ , il est utile donc de  s'assurer que les coefficients de nos vecteurs/matrices sont petits. Rappelons que ceci est important pour garantir que les termes d'erreur restent limités tout au long de l'évaluation homomorphique.
\subsection{Le schéma de chiffrement}
Nous allons maintenant explorer les opérations de chiffrement, de déchiffrement et d'évaluation homomorphes du schéma de chiffrement totalement homomorphe de \cite{10}.\\
Rappelons que l'espace du texte chiffré est constitué de matrices $\mathbf{N} \times \mathbf{N}$ sur $\mathbf{Z}_{q}$ pour un paramètre de dimension $\mathbf{N}$
et un module q. De manière plus détaillée, supposons que $C_{1}$ et $ C_{2} $  sont des chiffrés  de $ m_{1}$  et  $m_{2}$ , respectivement
\begin{align}
  C_{1}.v &= m_{1}.v + e_{1}\\
  C_{2}.v &= m_{2}.v + e_{2}
\end{align}
avec $e_{i}$  trés petit . Pour véerifier si ce schéma est homomorphe, nous pouvons alors voir que la somme et les produits des chifrés sont donnés par:
\begin{align}
  (C_{1} + C_{2}).v = (m_{1} + m_{2}).v + (e_{1} + e_{2})
\end{align}
\begin{align*}
  (C_{1} \circ C_{2})·v &= C_{1}·(m_{2}·v + e_{2}) \\
                        &=m_{2}·(m_{1}·v + e_{1})+C_{1}·e_{2} \\
                        &=m_{1}·m_{2}·v + (m_{2}·e_{1} + C_{1}·e_{2})
\end{align*}
où les termes $(e_{1}+e_{2 })$ et  $(m_{2}·e_{1} + C_{1}·e_{2})$  demeurent  petits.Formellement, le schéma est décrit ci-dessous. Suivant la présentation de \cite{10}, nous décomposons l'algorithme GEN en trois parties :
Setup, SecretKeyGen, et PublicKeyGen, comme ci-dessous dans l'Algorithme 4 :

\begin{algorithm}[H]
  \Procedure{SETUP}{$(1^{\lambda},1^L)$}
  \State Choisir un module de $\kappa = \kappa( \lambda,L )$
  \State Choisir la dimension latice (trellis) $ n = n(\lambda, L)$
  \State Choisir la distribution d'erreur $ \chi = \chi(\lambda,L)$ de manière appropriée pour LWE
  \State qui atteint au moins $2^{\lambda}$ sécurité contre les attaques connues
  \State Choisir le paramètre $ m = m(\lambda, L) = \Theta(n{\log (q)})$
   \State \textbf{return} $(\kappa, n ,\chi ,m)$
  \EndProcedure
\Procedure{SECRETKEYGEN}{$(\kappa, n ,\chi ,m)$}
\State Echantillon $ t \leftarrow \mathbf{Z^n}_{q}$
\State Définir $s_{k}=(1, {-}t_{1}, ..., {-}t_{n}) \in  \mathbf{Z^{n+1}}_{q}$
 \State \textbf{return} $s_{k}$
\EndProcedure

\Procedure{PUBLICKEYGEN}{$(\kappa, n ,\chi ,m,s_{k})$}
\State Echantillonner une matrice $ B \leftarrow \mathbf{Z^{m \times n}}_{q}$
\State Echantillonner un vecteur $ e \leftarrow  \chi^m$
\State Définir $ b = B.t + e $ où t peut être récupéré à partir de sk
\State Calculer $ p_{k} = A $  qui est une (n + 1)  matrice de colonnes où la 1ére
 colonne est b et les n colonnes suivantes sont B
 \State \textbf{return} $p_{k}$(notez  que $ p_{k}.s_{k} = e$ où $p_{k}$ est une matrice et $s_{k} $ et e sont des vecteurs).
\EndProcedure

 \caption{Algorithme de Setup, SecretKeyGen, and PublicKeyGen }
\end{algorithm}
L'algorithme 5 ci-dessous présente les principales opérations du schéma de chiffrement. Notez qu'il existe deux
algorithmes de déchiffrement : algorithme où  le message provient d'un petit espace d'échantillonnage (par exemple, $ \{0, 1\}$ ), et un qui fonctionne pour tout message dans $\mathbf{Z}_q$, bien que nous ne présentons que le cas où q est une puissance de 2.
Ce dernier algorithme de déchiffrement MPDecryption provient de \cite{13} et un traitement du cas général q peut être trouvé là aussi . Nous précisons également la manière dont les opérations homomorphes seront effectuées dans l'algorithme 6 ci-dessous :
\begin{algorithm}[H]
  \Procedure{ENC}{$(\kappa, n ,\chi ,m,p_{k},\mu \in \mathbb{Z}_q)$}
  \State Echantillonnez une matrice uniforme $ R \in \{0, 1\}^{N \times m$
  \State Calculer $ C = Flatten(\mu .I_{N} + BitDecomp(R.A)) \in \mathbb{Z^{\mathbb{N} \times \mathbb{N}}}_q$
   \State \textbf{return} $C$
  \EndProcedure
\Procedure{DEC}{$(\kappa, n ,\chi ,m,s_{k},C)$}
\State Calculer $ v = Powersof2(s_{k})$
\State Notez que les l premiers coefficients de v sont  $1,2,......,2^{l-1}$
\State Choisir i tel que $v_{i}=2^i \in (\frac{q}{4},\frac{q}{2})$
\State Calculer $x_{i}=\langle C_{i} , \mathbf{v} \rangle$ où $C_{i}$ est le ieme ligne de C
\State Calculer $\mu= \floor*{\frac{x_{i}}{v_{i}}}$
 \State \textbf{return} $\mu$
\EndProcedure
\Procedure{MPDecryption }{$(\kappa, n ,\chi ,m,s_{k},C)$}
\State  voir \cite{13}
\EndProcedure
 \caption{Le schéma de chiffrement complet }
\end{algorithm}

\begin{algorithm}[H]
  \Procedure{ADD}{$(C_{1},C_{2})$}
  \State Calculer $ C_{1} +C_{2}$
   \State \textbf{return} $Flatten(C_{1} +C_{2})$
  \EndProcedure
\Procedure{MULTCONST}{$(C,\alpha)$}
\State Calculer $ M_{\alpha} = Flatten(\alpha .I_{N})$
 \State \textbf{return} $Flatten(M_{\alpha}.C)$
\EndProcedure
\Procedure{MULT}{$(C_{1},C_{2})$}
 \State \textbf{return} $Flatten(C_{1} \times C_{2})$
\EndProcedure

\Procedure{NAND}{$(C_{1},C_{2})$}
 \State \textbf{return} $Flatten(I_{N}-C_{1}.C_{2})$
\EndProcedure
 \caption{Opérations homomorphes}
\end{algorithm}
Cette construction particulière utilise également les innovations de \cite{14} pour rendre facultative l'étape de bootstrapping commune à de nombreux schémas basés sur l'apprentissage avec les erreurs, ce qui
le rendant plus efficace.
\section{Réduction des schémas basés sur le treillis pour l'apprentissage avec des erreurs}
Outre l'apprentissage avec des erreurs(LWE), les problèmes basés sur des treillis constituent une autre primitive cryptographique importante.
Ils sont importants car les hypothèses de dureté les plus défavorables pour ces problèmes basés sur des treillis resistent même contre les ordinateurs quantiques. En outre, plusieurs schémas de chiffrement entièrement homomorphes ont été construits à l'aide de ces problèmes de treillis \cite{15}. Bien que nous n'explorions aucun schéma de chiffrement strictement basé sur des problèmes de treillis, nous introduirons brièvement la théorie de la cryptographie basée sur les treillis, puis nous présenterons une réduction du problème de treillis GapSVP souvent utilisé à l'apprentissage avec erreurs.
\subsubsection{Définition 4}
Un treillis (de rang complet) à n dimensions est un sous-groupe discret et additif de $\mathbf{R^n}$. De manière équivalente, si nous avons une base de n vecteurs linéairement indépendants $ \mathbf{B} = \{\mathbf{b}_1, ...., \mathbf{b}_n \}  \subset \mathbf{R^n}$
alors le treillis $\wedge$ généré par la base $\mathbf{B}$ est l'ensemble
\begin{align}
  \wedge = \mathcal{L}(\mathbf{B})=\Bigg\{  \sum_{i}^{n}c_{i}b_{i}  |  \   c_{i} \in \mathbb{Z}   \Bigg\}
\end{align}
\subsubsection{Définition 5}
Le treillis dual d'un treillis $\wedge$, noté $\wedge^* $ est $ \wedge^* = \Big\{{x \in \mathbf{R^n} |  \  \forall v \in \wedge,\langle \mathbf{x} , \mathbf{v} \rangle \in \mathbf{Z} \Big\}$ .
\subsubsection{Définition 6}
La distance minimale $\lambda_{l}(\wedge)$ d'un treillis $\wedge$ (dans la norme $l_{2}$ par défaut) est la distance minimale entre deux points distincts quelconques du treillis dans $\wedge$. Cela équivaut à la longueur du vecteur non nul le plus court du treillis, Soit
\begin{align}
  \lambda_{l}(\wedge)=\min_{x_{1} \neq x_{2} ,x_{1},x_{2} \in \wedge}\norm{x_{1}-x_{2}} = \min_{ c \neq 0; x \in \wedge}\norm{x}
\end{align}
\subsubsection{Définition 7}
Étant donné une fonction $\gamma(n) \geq 1 $ , le problème du vecteur le plus court $GapSVP_{\gamma}(\mathbf{B}, d)$ , où $\mathbf{B}$ est une base d'un treillis à n dimensions $ \wedge = \mathcal{L}(\mathbf{B})$  et  $d \in \mathbb{R^+}$  est le problème de déterminer si .
$ \lambda_{l}(\wedge) \leq d$. En particulier, il requiert une sortie de 1 si$ \lambda_{l}(\wedge) \leq d $ et une sortie de 0 si $\lambda_{l}(\wedge) > \gamma(n).d $\\
\\
En 2009, Peikert a prouvé une réduction d'une variante particulière du problème du plus court vecteur $ GapSVP_{\zeta,\gamma}$
défini ci-dessous à des versions correspondantes du problème de l'apprentissage avec erreurs \cite{16}. Pour être complet, nous présentons l'énoncé et la preuve du théorème dans \cite{16}. Tout d'abord, nous définissons la variante $ GapSVP_{\zeta,\gamma}$  du problème du plus court vecteur
\subsubsection{Définition 8}
Étant donné les fonctions $ \zeta(n) \geq \gamma(n) \geq 1$, le problème du plus court vecteur $\zeta$-to-$\gamma$ $ GapSVP_{\zeta,\gamma}(\mathbf{B},b)$ ,où\\
1.) $\mathbf{B}$ est une base d'un treillis à n dimensions $ \wedge = \mathcal{L}(\mathbf{B})$ où  $\lambda_{l}(\wedge) \leq \zeta(n).$ \\
2.) $\min_{i}\norm{b_{i}} \geq 1$\\
3.) $1 \leq d\leq \frac{\zeta(n)}{\gamma(n)}$\\
est le problème consistant à déterminer si  $\lambda_{l}(\wedge) \leq d $. En particulier, il requiert une sortie de 1 si $\lambda_{l}(\wedge) \leq d $ et une sortie de 0 si $\lambda_{l}(\wedge) > \gamma(n).d $.\\
\\
Notons que pour tout $\zeta(n) \geq 2^{\frac{n}{2}} , $ GapSVP_{\zeta,\gamma}$  est équivalent au problème standard du plus court vecteur $ GapSVP_{\gamma}$ .
Ceci est dû au fait que, par l'algorithme de Lensta-Lenstra-Lovász \cite{17}, une base arbitraire B pour un treillis $\wedge$ peut être réduite en temps polynomial à une autre base  B' qui couvre le même treillis, et telle que
\begin{align}
  \lambda_{l}(\wedge) \leq \norm{\mathbf{b'}_{1}} \leq 2^{\frac{n}{2}}.\min_{i}\norm{b_{i}}
\end{align}
Puisque nous pouvons toujours mettre à l'échelle la base du treillis d'origine B de telle sorte que $\min_{i}\norm{b_{i}} =1 $ , nous pouvons réduire toute instance du problème du plus court vecteur à une instance où la distance minimale est garantie comme étant inférieure à $2^{\frac{n}{2}}$. Cela rend la limite imposée par la condition (1) trivialement vraie. Nous n'avons pas à nous soucier des conditions (2) et (3) car nous pouvons toujours réduire les bases de sorte que (2) soit vraie, et la solution est triviale si (3) n'est pas vraie (et si (1) et (2) sont toutes deux vraies).\\
\\
Maintnantnous allons   passer à la réduction, nous énonçons quelques lemmes qui seront utilisés. Pour un traitement plus complet de l'objet de ces lemmes, voir \cite{16}. Pour la notation, on désigne par $B_{n} \subset \mathbf{R^n}$ la boule unitaire ouverte (dans la norme $ l_{2}$), c'est-à-dire l'ensemble $ B_{n} = \{x \in \mathbf{R^n} \ | \norm{\mathbf{x}} \leq 1 \}$ .
\subsubsection{lemme 5}
Soit $\Delta(X,Y)$ la différence statistique entre les distributions X et Y , et U(S) la distribution uniforme sur un ensemble S. Pour toute constante c, d > 0 et tout $z \in \mathbf{R^n}$ avec $\norm{z} <d $,et
$ d'=d.\sqrt{\frac{n}{c\log(n)}} $ , on obtient que
\begin{align}
  \Delta(U(d'.B_{n}),U(\mathbf{z}+d'.B_{n})) \leq 1 -\frac{1}{poly(n)}
\end{align}
\subsubsection{Démonstration}
Voir \cite{18} pour la démonstration

Nous utilisons également le concept de paramètre de lissage de \cite{19}. Intuitivement, le paramètre de lissage
est le plus petit r qui lisse la structure discrète de $\wedge$, jusqu'à une certaine erreur statistique .\\
Nous allons énoncer le théorème de la réduction ,il y'a d'aures lemmes intéressants qui pourront aider à la comprehension et à la démonstration du théorème ,nous allons renvoyer la lecteur à \cite{16} pour un traitement complet
\subsubsection{Theoréme}
 Soit $ \alpha = \alpha(n) \in (0, 1) $  et $ \gamma = \gamma(n) \geq \frac{n}{\alpha\sqrt{\log(n)}}$ .
 Soit $ \zeta = \zeta(n) \geq \gamma(n)$ et $ q = q(n) \geq \zeta(n).ω\sqrt{\frac{\log(n)}{n}} $ . Alors, il existe une réduction probabiliste en temps polynomial de la résolution de $ GapSVP_{\zeta,\gamma}$  dans le pire des cas (avec une probabilité écrasante) à la résolution de $ LWE_{q,Ψa}$ en utilisant des échantillons poly(n).
 \subsubsection{Démonstration}
 voir \cite{16} pour la démonstration\\
 \\
 Cependant, \cite{16} ne fonctionne que pour les problèmes LWE avec de grands modules $ q \geq $q 2^{\frac{n}{2}}$ . Plus tard, il est  prouvé une réduction similaire qui fonctionne pour des modules polynomiaux. Ces résultats montrent que le GapSVP peut être réduit au LWE.
 \section{Encodage des nombres réels}
 Un détail technique important qui doit être discuté lors de l'examen des applications des schémas de chiffrement partiellement/totalement homomorphes aux algorithmes d'apprentissage automatique est le codage des nombres réels.La plupart des schémas de chiffrement homomorphes utilisent $\mathbf{Z}_q$ pour un certain q comme espace de message. Par conséquent, ils sont naïvement incapables de chiffrer des valeurs réelles. Dans cette section, nous explorons brièvement une méthode de codage de nombres réels employée dans les applications de machine learning  utilisées dans \cite{20}, \cite{21}.\\
 \\
 Dans \cite{20}, les nombres réels sont comme des vecteurs de bits signés(+ ou -) de taille $ L + l + 1$ bits, et un nombre réel $a \in \mathbf{R} $ est représenté par .
 \begin{align}
   a=\sum_{-L}^{l}a_{k}2^k
 \end{align}
 où $ a_{k} \in \{0, 1\}$  si  $ a \geq 0$ et  $a_{k} \in \{0, -1\}$  si $ a < 0 $\\ Pour les opérations sur les nombres réels avec ce codage, on a
 \begin{align*}
   a + b= \sum_{-L}^{l}(a_{k}+b_{k})2^k=\Big\langle [2^{-L},.....2^{0}......,2^{l}],(Bits(a)+Bits(b)) \Big\rangle
 \end{align*}
 \begin{align*}
   ab&=\Big\langle [2^{-L},.....2^{0}......,2^{l}],(Bits(a) \Big\rangle.\Big\langle Bits(b), [2^{-L},.....2^{0}......,2^{l}] \Big\rangle \\
   &=[2^{-L},.....2^{0}......,2^{l}].\Big\langle Bits(a),Bits(b) \Big\rangle.[2^{-L},.....2^{0}......,2^{l}]
 \end{align*}
 Notez que ce schéma de codage est flexible, car nous pouvons choisir L à l'avance pour obtenir la précision décimale souhaitée et l pour définir notre valeur entière maximale.  On pourrait craindre que cette perte de précision n'ait peut avoir un impact négatif sur les performances prédictives de nos algorithmes d'apprentissage automatique. Cependant, des chercheurs  on étudié l'impact de la perte de précision sur des algorithmes tels que les classificateurs de réseau bayésien  et n'ont constaté aucune perte de performance significative, à condition que les probabilités ne soient pas trop proches de 0 ou de 1 et que les probabilités postérieures sur les classes soient suffisamment différentes. sur les classes sont suffisamment différentes \cite{22} . Cela suggère qu'il existe des algorithmes d'apprentissage algorithmes d'apprentissage automatique capables de tolérer un certain niveau de perte de précision.
