\section{cryptosystéme simplement homomorphe de RSA }
L'algorithme RSA conçu par Rivest, Shamir et Adleman en 1978 est largement utilisé aujourd'hui pour transmettre en toute sécurité de petites clés secrètes entre les deux parties, qui peuvent ensuite être utilisées pour communiquer en toute sécurité  avec des messages beaucoup  plus importants grâce à des systèmes de chiffrement à clé privée efficaces.(chiffrement hybride)\\
Nous allons explorer les propriétés homomorphes que le RSA possède, même s'il n'a pas été spécifiquement conçu dans ce but. Tout d'abord, nous définissons formellement le RSA ci-dessous :\\
\begin{algorithm}[H]
$
\Procedure{GEN}{$(1^{\lambda}) }
  \State On Choisit 2 nombres premiers  aléatoires p, q, et on  calcule N = pq
  \State On calcule $\phi{(N)}$=$(p-1)(q-1)$
  \State On choisit e >1 tel que pgcd(\phi{(N)}$ ,e)=1   et on calcule  d= e^{-1}mod \ \phi{(N)}$
 \State \textbf{return} $(N,e,d)$
\EndProcedure

\Procedure{ENC}{$(m,N,e)$}
 \State \textbf{return} $c= m^{e}mod \ d$
\EndProcedure

\Procedure{DEC}{$(c,N,d)$}
 \State \textbf{return} $m= c^{d}mod \ N$
\EndProcedure



 \caption{Algorithme de RSA \cite{1}}
\end{algorithm}
\\
Nous pouvons facilement voir que les schémas de chiffrement  et de déchiffrement de  RSA sont corrects puisque on a :
\begin{align*}
  DEC{_(}{_N,}{_d}{_)}(ENC{_(}{_N,}{_e}{_)})(m)&=  DEC{_(}{_N,}{_d}{_)}(m^{e} mod \ N)\\
                                               &=m^{de} mod \ N \\
                                               &=m \ mod \ N
\end{align}
De plus, notez que l'algorithhme  RSA prend pour acquis que nous pouvons générer des nombres premiers de $\lambda$-bit  pour tout $\lambda$ $\in$ $ \mathbf{Z}^{+}$ . Ce n'est certainement pas une hypothèse triviale, mais de nombreux schémas simples qui génèrent des nombres de $\lambda$-bit aléatoires et utilisent des tests de primalité comme le test de Miller-Rabin fonctionnent bien en pratique \cite{1}. Une discussion plus approfondie des méthodes permettant de générer des nombres premiers  de  $\lambda$-bit dépasse le cadre de ce mémoire , nous supposerons donc que nous pouvons générer efficacement de tels nombres premiers.
\\
Dans ce qui , nous montrerons que RSA est un schéma de chiffrement homomorphe valide qui supporte la multiplication
modulo N.
\subsubsection{Proposition1}
 RSA  est un schema  de chiffrement valide et partiellement homomorphe. En particulier, la multiplication des messages chiffrés modulo N correspond à la multiplication des messages clairs modulo N.
 \subsubsection{Démonstration}
 Soit $ENC{_(}{_N,}{_e}{_)}$ l'algorithme de chiffrement et $m{_1}$ et $m{_2}$ $\in$ $ \mathbf{Z}_{N}$  deux messages,alors on a
\begin{align*}
  ENC{_(}{_N,}{_e}{_)}(m{_1})ENC{_(}{_N,}{_e}{_)}(m{_2})&=m{_1}^e.m{_2}^e mod \ N \\
                                                        &=(m{_1}m{_2})^e mod \ N \\
                                                        &=ENC{_(}{_N,}{_e}{_)}(m{_1}m{_2})
\end{align*}
Ainsi, on peut voir que multiplier les chifrés modulo N correspond à multiplier les messages en clair modulo N.\\
Malheureusement, même si nous prenons l'hypothèse RSA comme acquise, il existe un certain nombre d'attaques sur le RSA  qui le rendent peu sûr \cite{1}. En fait, comme le RSA est déterministe, il ne peut pas être CPA-sùr. Cependant, nous pouvons au moins voir que l'idée d'un chiffrement homomorphe est réalisable car RSA est capable d'obtenir l'homomorphisme sans que ce soit son objectif.
\section{Cryptosystème de Paillier}
Dans cette section, nous explorons un schéma de chiffrement homomorphe additif proposé par Paillier en 1999 \cite{11}.Ce schéma utilise le problème de la classe de résidu composite, qui est étroitement lié au système RSA.Bien qu'il ne soit pas totalement homomorphe, le schéma de chiffrement de Paillier est utilisé dans de nombreuses  applications de machine learning  que nous explorons dans ce mémoire. Une caractéristique intéressante du cryptosystème de Paillier est qu'il est homomorphe sur un grand nombre de messages , c'est-à-dire sur $\mathbb{Z}_\mathbb{N}$. Un exemple courant de cas d'utilisation du cryptosystème de Paillier
est le calcul du nombre de votes chiffrés, puisque les sommes résultantes peuvent atteindre des totaux élevés \cite{1}.Depuis sa création, le cryptosystème de Paillier a également subi des améliorations pour le rendre plus efficace .Nous décrivons l'algorithme ci-dessous (Algorithme 2), nous illustrons la réduction à RSA et nous donnons une
preuve de sécurité, en suivant les exposés de \cite{11}, \cite{1}. En particulier, nous présentons de nombreux détails de \cite{11} mais pour la clarté de la présentation, nous utilisons la notation et la terminologie de \cite{1}.
\subsection{Le système de chiffrement }
Pour le cryptosystème de Paillier, l'espace de message M = $\mathbb{Z}_{N}$ ,l'espace de clés $\mathcal{K}$= $\mathcal{K}${_p_k}$ $ $\times$ $\mathcal{K}${_s_k}$ où $\mathcal{K}${_p_k}$=$\mathbb{Z}_{N}$ et l' espace des  chiffrés $\mathcal{C}$=$\mathbb{Z}_{N^2}$
\begin{algorithm}[H]
  \Procedure{GEN}{$(1^\lambda)$}
  \State On Choisit 2 nombres premiers aléatoires p, q, de $\lambda$-bit
  \State On calcule N=pq et $\phi{(N)}$=$(p-1)(q-1)$

   \State \textbf{return} (N,$\phi{(N)} $)
  \EndProcedure
\Procedure{ENC}{$(m,N)$}
  \State r $\leftarrow $  $\mathbb{Z}_{N^*}$
  \State $c=(1+N)^m.r^n(mod \ N^2)$
 \State \textbf{return} $c$
\EndProcedure

\Procedure{DEC}{$(c,N,\phi{(N)})$}
\State Calculer  $ \widetilde{c} = c^{\phi{(N)}} mod \ N^2 $
\State Calculer $\widetilde{m}=\frac{\widetilde{c}-1}{N}$
\State Calculer $m=\widetilde{m}.\phi{(N^-1) mod \ N^2$
 \State \textbf{return} $m$
\EndProcedure


 \caption{Algorithme de Paillier \cite{1} ,\cite{11}}
\end{algorithm}
Pour démontrer l'exactitude du cryptosystème de Paillier, nous examinons l'espace du texte chiffré : le groupe$\mathbb{Z^*}_{N^2}$ sous multiplication modulo $N^2$ et introduisons la notion de  $N^{ieme}$ résidus, qui sont importants pour le cryptosystème de Paillier.
\subsubsection{definition}
Un entier z $\in$ $\mathbb{Z^*}_{N^2}$  est  un $N^{ieme}$ résidus modulo $N^2$ ,s'il existe y $\in$ $\mathbb{Z^*}_{N^2}$ tel que
\begin{equation}
  z &\equiv y^N \mod N^2 \\

\end{equation}
Pour revenir à la démonstration de  l'exactitude du cryptosytéme, nous devons prouver que le schéma de chiffrement  est univoque et que le système de déchiffrement est correct. La première est importante car si deux plaintexts sont mis en correspondance avec le même ciphertext, alors l'algorithme de déchiffrement ne pourra pas déchiffrer correctement. Donc, fixons un $N^{ieme}$ résidu g $\in$ $\mathbb{Z^*}_{N^2}$ et Notons  $\epsilon_{g}$  la fonction
\begin{align}
  \epsilon_{g}:\mathbb{Z}_{N} \times \mathbb{Z^*}_{N} \longrightarrow  \mathbb{Z^*}_{N^2}\\
               (x,y) \longrightarrow  g^x.y^N (mod \ N^2)
\end{align}
\subsubsection{lemme 1}
Si l'ordre de g $\in$ $ \mathbb{Z^*}_{N^2}$ est un miltiple non nul de N ,alors $\epsilon_{g}$ est bijective
\subsubsection{preuve}
Nous allons d'abord montrer que  $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ et $ \mathbb{Z^*}_{N^2}$ ont le meme nombre d'élements,
 $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ a N $\phi{(N)}$élements avec $\phi{}$la fonction d'Euler .\\
 Soit $N=\prod_{i}p{_i}^{e{_i}}$ la décomposition en produit de facteur premier de N.notez que
 \begin{align*}
   \phi{(N)}&=\prod_{i}\phi{(p{_i}^{e{_i}})}
                ( \phi{}  est multiplicative)
           \\  &=\prod_{i}p{_i}^{e{_i}-1}(p{_i}-1)
 \end{align*}
Ainsi on a,
\begin{align*}
  \phi{(N^2)}&=\prod_{i}\phi{(p{_i}^{2e{_i}})}\\
             &=\prod_{i}p{_i}^{2e{_i}-1}(p{_i}-1)\\
             &=(\prod_{i}p{_i}^{e{_i}})(\prod_{i}p{_i}^{e{_i}-1}(p{_i}-1))\\
             &=N\phi{(N)}
\end{align*}
Ainsi  $\mathbb{Z}_{N} \times \mathbb{Z^*}_{N}$ et $ \mathbb{Z^*}_{N^2}$ ont le meme nombre d'élements,il suffit alors de montrer que $\epsilon_{g}$ est injective.\\\
Supposons que $g^{x{_1}}.y_{1}^{N}=g^{x{_2}}.y_{2}^{N} (\ mod \ N^2) \implies g^{x{_2}-x{_1}}(\frac{y_{2}}{y_{1}})^N &\equiv 1 \mod N^2 $. soit $\lambda$ le plus grand entier pour lequel il existe un élément de $ \mathbb{Z^*}_{N^2}$ d'ordre $\lambda$N.Ainsi $ (\frac{y_{2}}{y_{1}})^{\lambda N} &\equiv 1 \mod N^2 \implies g^{\lambda(x{_2}-x{_1})} &\equiv 1 \mod N^2  $.
Ceci implique que $\lambda(x{_2}-x{_1}) $ est un multiple de l'ordre de g et donc un multiple de N.Ainsi $Pgcd(\lambda ,N)=1 \implies  x{_2}-x{_1} &\equiv 0 \mod N$ donc $(\frac{y_{2}}{y_{1}})^N &\equiv 1 \mod N^2 $ qui admet une solution unique $\frac{y_{2}}{y_{1}}=1 $ sur $ \mathbb{Z^*}_{N^2}$.d'où x{_1}$- x{_2}$=0 et y{_1}$- y{_2}$=0 et $\epsilon_{g}$ est bijective\\
\\
Il découle alors de la bijectivité que l'algorithme de chiffrement ne fait pas correspondre deux messages distincts sur le même texte chiffré. Quant à l'exactitude de l'algorithme de déchiffrement du cryptosystème de Paillier, nous avons la proposition suivante
\subsubsection{Proposition2}
L'algorithme de déchiffrement du cryptosystème Paillier est correct. Plus précisément, pour un certain m $\in$ \mathbb{Z}_{N}  , alors$DEC_{\phi{(N)}}(ENC_{N}(m))=m$
\subsubsection{démonstration}
Observons que
\begin{align*}
   \widetilde{c}&=c^{\phi{(N)}} mod \ N^2 \\
                &=(1+N)^{m\phi{(N)}}r^{n\phi{(N)}} mod \ N^2\\
                &\leftrightarrows (m\phi{(N)mod \ N},r^{\phi{(N)}}mod \ N)            \ (bijection)\\
                &=(m\phi{(N)mod \ N},1)                \  \ (r^{\phi{(N)}}=1 mod N ,si r et N sont premiers entre eux)\\
                &\leftrightarrows (1+N)^{m\phi{(N)}} mod \ N^2   \ (bijection)\\
                &=1+ m\phi{(N)}N \ mod \ N^2
\end{align*}
Ainsi , on obtient
\begin{align*}
  (\frac{\widetilde{c}-1}{N}).\phi{(N)}^{-1}=m
\end{align*}
Ainsi le schéma de déchiffrement est donc correcte\\
Maintenant que nous avons vérifié l'exactitude des algorithmes de chiffrement et de déchiffrement, nous pouvons passer à l'examen de la sécurité du cryptosytéme de Paillier. Le problème difficile sur lequel le cryptosystème de Paillier est basé est le problème de résidu composite décisionnel, qui consiste à distinguer
entre les éléments uniformes de $ \mathbb{Z^*}_{N^2}$ et les $ n^{ieme}$  residus de $ \mathbb{Z^*}_{N^2}$.Plus formellement, nous définissons ce que signifie le fait que le problème de résidu composite décisionnel soit difficile, en utilisant la définition de \cite{1}.
\subsubsection{définition 1}
Le problème de la résiduosité composite décisionnelle est difficile si, pour tous les algorithmes probabilistes en temps polynomial D, il existe une fonction négligeable negl telle que pour r choisi aléatoirement parmi $ \mathbb{Z^*}_{N^2}$
\begin{align*}
  |Pr[ D(N,r^{N} mod \ N^2)=1]-Pr[D(N,r)=1]| \leq negl(n)
\end{align*}
Dans la présentation originale de ce schéma par Paillier, il explore le problème de la $n^{ieme}$  classe de résidu et démontre que sa résolution nous donne un distinguateur pour le problème de résidu composite décisionnel ci-dessus. La  $n^{ieme}$  classe de résidu est définie comme suit :
\subsubsection{définition 2}
Soit g $\in$ $ \mathbb{Z^*}_{N^2}$ ayant un ordre non nul multiple  de N. Nous appelons la $N^{ieme}$ classe de résidu de w par rapport à g, l'unique entier $ [[w]]_{g}$ $\in$ $Z_{n}$ pour lequel il existe y tel que
\begin{align*}
  \epsilon_{g}([[w]]_{g},y) &=  ([[w]]_{g})^{g}.y^N =w
\end{align*}
Notez que ce problème est bien défini car $[[w]]_{g}$ est unique, ce qui vient du fait que $\epsilon_{g}$ est bijective (par le Lemme).
\subsection{Réduction en RSA}
\subsubsection{définition 3}
Le $N^{ieme}$ problème de classe de résidu de la base g, Classe[N, g] est le problème suivant. Étant donné
w $\in$ $ \mathbb{Z^*}_{N^2}$ et une base g, calculer  $[[w]]_{g}$ .\\

Le résultat suivant nous montre  comment le problème de la $N^{ieme}$ Classe de Résiduosité nous donne un distinguateur D pour le problème de la résiduosité composite décisionnelle.
\subsubsection{lemme 2}
$[[w]]_{g}$ = 0 si et seulement si w est un Nième résidu modulo $N^2$ \\
\subsubsection{Démonstration}
Voir \cite{11} pour la démonstration.
\\
\\
Ainsi, si nous pouvions résoudre le probléme de la $N^{ieme}$ classe de résidu, un simple distinguateur D pourrait prendre r et calculer $[[r]]_{g}$ pour un certain g approprié. Si le résultat est 0 , alors il sort 1 (en devinant que c'est un $N^{ieme}$ résidu).Sinon, il produit 0.Il est facile de voir que cela présente un avantage non négligeable.En effet, par le lemme 1 et le lemme précédent, une proportion non triviale d'éléments de $ \mathbb{Z^*}_{N^2}$ ne sont pas des $N^{ieme}$ résidus, c'est-à-dire exactement une proportion $\frac{N-1}{N}$ d'entre eux.
\\
Jusque ici , une instanciation particulière du problème de la $N^{ieme}$ classe de résidu dépend de plusieurs paramètres, à savoir N, g et w. D'après les deux lemmes suivants, il s'avère que tous ces paramètres n'influencent pas la difficulté du problème. Tout d'abord, notons que dans la construction de ce distinguateur, nous n'avons pas précisé quelle valeur de g choisir. Le lemme suivant nous montre que cela n'a pas d'importance.
\subsubsection{lemme 3}
La classe [N, g] est aléatoirement auto-réductible sur tous les g' dont l'ordre est un multiple non nul de N.
\subsubsection{démonstration}
Voir \cite{11} pour la démonstration
\\
\\
Une autre propriété intéressante de la classe [N, g] est le fait qu'elle est aléatoirement auto-réductible. Plus précisément, nous pouvons réduire une instance du problème pour une valeur w $\in$ $ \mathbb{Z^*}_{N^2}$ en une instance aléatoire w' $\in $ $ \mathbb{Z^*}_{N^2}$    tiré d'une distribution uniforme.
\subsubsection{lemme 4}
La classe [N, g] est aléatoirement auto-réductible sur w $\in$ $ \mathbb{Z^*}_{N^2}$
\subsubsection{démonstration}
En effet, on peut facilement transformer tout w $\in$ $\mathbb{Z^*}_{N^2}$ en une instance aléatoire w' $\in$
$\mathbb{Z^*}_{N^2}$ avec une distribution uniforme, en posant  $w' = w g^{a}b^n mod N^2$ où a et b sont pris uniformément au hasard sur $ \mathbb{Z}_{N}$  (l'événement b $\notin$ $ \mathbb{Z}_{N}$ se produit avec une probabilité négligeable). Après avoir calculé $[[w']]_{g}$ , il suffit de retourner $[[w]]_{g} = [[w']]{_g} - a mod N$.
\\
Ainsi, nous voyons que nos choix de w $\in$ $\mathbb{Z^*}_{N^2}$ et g un $N^{ieme}$ résidu modulo N n'affectent pas la difficulté du problème de la  $N^{ieme}$ classe de résidu. Par conséquent, il nous suffit de choisir le paramètre N, et nous pouvons donc désigner une instanciation de ce problème par Classe[N].

\subsubsection{Théoréme (Réduction en RSA)}
La classe [N] est réductible en RSA
\subsubsection{Démonstration}
Nous savons que les élements de la classe [N, g] avec un ordre non nul multiple de N sont équivalentes  à g .En utilisant g = 1 + N, nous avons seulement besoin de montrer que
\begin{align*}
  RSA \rightrightarrows Class[N, 1 + N]
\end{align*}
Supposons maintenant que nous ayons un oracle S pour RSA .
\\
On a  $c=(1+N)^{m}y^{N} mod \ N^2$ avec m  $\in$  $ \mathbb{Z}_{N}$  et y $\in$  $ \mathbb{Z^*}_{N}$ .En developpant  $(1+N)^m$ (avec la loi de binome) et en appliquant la reduction modulo N on obtient $c=y^N mod \ N$ et on peut calculer y en utilisant l'oracle  S .On a alors $y=S(c mod \ N)$ ainsi nous avons
\begin{align*}
              c&=(1+N)^my^N mod \ N^2\\
 \frac{c}{y^N}&=(1+N)^m mod \ N^2\\
              &=1+mN \ mod \ N^2
\end{align*}
Ainsi on pourra  calculer  $m = [[c]]_{1+N}$  , comme souhaité, ce qui résout la classe [N]
\\
Ainsi, nous avons montré que le problème décisionnel du  cryptosystème de Paillier et RSA sont des schémas de chiffremente étroitement liés en ce sens et  que le premier est au plus aussi difficile que la factorisation du RSA. Cependant, cela ne le rend pas automatiquement sûr. Ci-dessous, nous montrons que le cryptosystème de Paillier est CPA-sécurisé en supposant que le problème de résidu composite décisionnel est difficile, en utilisant une preuve  de \cite{1}.
\subsection{Preuve de sécurité}
Avant de présenter la preuve de la sécurité, nous montrons un résultat standard de la théorie des groupes.
\subsubsection{proposition 3}
Si G est un groupe fini et que g $\in$ G soit choisi arbitrairement. Alors, si on choisit une distribution uniforme
k $\in$ G, alors la distribution de $ g \circ k$ ∈ G est également uniforme.
\subsubsection{Démonstration}
On a   pour tout g' $\in$ G ,il existe un k $\in$ G (c-à-d $k=g^{-1}\circ g'$) tel que \\
$g \circ k=g\circ g^{-1} \circ g' =g'$
\\
Maintenant, nous pouvons prouver la sécurité CPA conditionnelle du cryptosystème de Paillier.
\subsubsection{Théorème}
Si le problème de résidu composite décisionnel est difficile, alors le cryptosystème de Paillier
est CPA-sécurisé.
\subsubsection{démonstration}
Soit $ \epsilon = (GEN, ENC, DEC) $ le cryptosystème de Paillier. Comme le système de Paillier est un schéma de chiffrement à clé publique, il suffit de montrer que E est sécurisé par EAV. Alors, par la proposition 2 du chapitre 1 , cela implique qu'il est sécurisé par CPA.
Nous allons construire  une réduction du problème de résidu composite décisionnel pour casser la sécurité EAV pour le cryptosystème de Paillier. Ensuite, comme nous supposons que le problème de résidu composite décisionnel est difficile, nous ne devons pas être en mesure de casser la sécurité EAV pour le cryptosystème de Paillier.
Soit $\mathbb{A }$ un adversaire probabiliste en temps polynomial. Considérons l'algorithme D suivant qui tente de résoudre le problème de résidu composite décisionnel en se déroulant  comme suit et prenant en  entrée N, et y\\
1.) Définir $ pk = N$ et exécuter $ \mathbb{A}(pk)$ pour obtenir deux messages $m_{0}$, $m_{1}$ $\in$ M\\
\\
2.)Choisir un bit uniforme b $\in$  $\{ 0,1 \}$   et calculer le  chiffré $c=(1 +N)^{m_{b}}.y mod \ N^2$\\
3.)On donne le chiffré c à $\mathbb{A}$ comme challenge et $\mathbb{A}$  produit un bit b' .Si b=b'  on sort 1 sinon 0\\
Premièrement, si l'entrée de D avait un y qui a été tiré de en prenant un aléa  r $\in$ $\mathbb{Z^*}_{N^2}$ et en l'élevant à la puissance N, on aura alors $c=(1 +N)^{m_{b}}.r^N mod \ N^2$ .Dans ce cas, nous notons que si  $\mathbb{A}$  a été capable de distinguer correctement les chifrés de $m_{0}$ et $m_{1}$ (c'est-à-dire si b = b'), cela est équivalent à ce que D réussisse à déterminer si y a été tiré uniformément de $\mathbb{Z^*}_{N^2}$ ou de $ Res(N^2)$ . Par conséquent, nous avons que.
\begin{align*}
Pr[ D(N,r^{N} mod \ N^2)=1]=Pr[PubK^{eav}{_A,_{\epsilon}}(n) =1]
\end{align*}
Maintenant, on observe que si notre entrée à D avait un y qui était tiré au hasard de $\mathbb{Z^*}_{N^2}$ , alors par la Proposition 3 précédent, le texte chiffré c est distribué uniformément dans $\mathbb{Z^*}_{N^2}$  ,indépendamment de m. Ainsi, la probabilité que $ b'= b$ est exactement $\frac{1}{2}$ et en particulier
\begin{align*}
  Pr[ D(N,r)=1]&=\frac{1}{2}
\end{align*}
Maintenant, en utilisant l'hypothèse que le problème de résidu composite décisionnel est dur, nous savons  alors  qu'il  existe une fonction négligeable negl telle que
\begin{align*}
  |Pr[D(N,r^{N} mod \ N^2)=1]- Pr[ D(N,r)=1]|\leq negl(n)
\end{align*}
ainsi , on a
\begin{align*}
   |Pr[PubK^{eav}{_A,_{\epsilon}}(n) =1]-\frac{1}{2}|\leq negl(n)
\end{align*}
Cela montre donc que le cryptosytéme de Paillier est sécurisé par EAV, et donc sécurisé par CPA.
